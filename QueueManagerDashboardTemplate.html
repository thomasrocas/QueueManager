<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RCM Dashboard Chart.js</title>
  <script src="https://unpkg.com/feather-icons"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@yaireo/tagify/dist/tagify.css" />
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
  <link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.4.1/css/buttons.dataTables.min.css">
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
  <script src="https://cdn.datatables.net/buttons/2.4.1/js/dataTables.buttons.min.js"></script>
  <script src="https://cdn.datatables.net/buttons/2.4.1/js/buttons.html5.min.js"></script>
  <script src="https://cdn.datatables.net/buttons/2.4.1/js/buttons.colVis.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@yaireo/tagify"></script>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
    .sidebar {
      width: 137px;
      background: #f4f4f4;
      padding: 10px;
      transition: width 0.3s ease;
      position: relative;
    }
    .sidebar.collapsed { width: 44px; }
    .toggle-arrow {
      position: absolute;
      top: 15px;
      right: -10px;
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
    }
    .sidebar h3 { font-size: 16px; margin-bottom: 20px; }
    .sidebar.collapsed h3,
    .sidebar.collapsed .menu-text { display: none; }
    .menu-item { display: flex; align-items: center; padding: 10px; margin: 5px 0; cursor: pointer; border-radius: 5px; }
    .menu-item:hover,
    .menu-item.active { background-color: #dceeff; }
    .menu-item i { margin-right: 10px; }
    .main-content {
      flex: 1;
      padding: 24px 36px;
      overflow-y: auto;
      background: #fff;
    }
    #dashboard {
      max-width: 1350px;
      margin: 0 auto;
    }
    .dashboard-title {
      font-size: 2.1em;
      font-weight: bold;
      margin-bottom: 24px;
      color: #0066bb;
      letter-spacing: 0.01em;
    }
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 28px;
      margin-bottom: 36px;
    }
    .chart-card {
      background: #f9fbfc;
      border-radius: 16px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
      padding: 24px 20px 16px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 320px;
      transition: transform 0.3s, opacity 0.3s;
      cursor: zoom-in;
    }
    .chart-card.zoomed {
      transform: scale(1.5);
      position: relative;
      z-index: 1000;
      cursor: zoom-out;
    }
    .chart-card.dimmed {
      opacity: 0.3;
      transform: scale(0.7);
    }
    .chart-title {
      font-size: 1.12em;
      font-weight: bold;
      color: #34495e;
      margin-bottom: 6px;
      letter-spacing: 0.01em;
      text-align: center;
    }
    #data-table {
      margin-top: 18px;
      border-radius: 14px;
      overflow-x: auto;
      box-shadow: 0 2px 10px rgba(0,0,0,0.04);
      background: #f9fbfc;
      padding: 18px;
    }
    #data-table table {
      border-collapse: collapse;
      width: 100%;
      background: transparent;
      font-size: 0.98em;
    }
    #data-table th, #data-table td {
      border: 1px solid #e4e4e4;
      padding: 8px 14px;
      text-align: left;
    }
    #data-table th {
      background: #f0f5fa;
      font-weight: 700;
    }
    #data-table tr:nth-child(even) {
      background: #f8fafc;
    }
    .filter-label {
      font-size: 1em;
      margin-bottom: 4px;
      color: #007bff;
      font-weight: 500;
    }
    #chartDropdown {
      margin: 0;
    }
    #chartOptions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .right-panel-toggle {
      position: fixed;
      top: 50%;
      right: 0;
      width: 30px;
      height: 60px;
      background-color: white;
      color: #007bff;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-top-left-radius: 8px;
      border-bottom-left-radius: 8px;
      z-index: 999;
    }
    .right-panel {
      position: fixed;
      top: 0;
      right: -400px;
      width: 320px;
      height: 100%;
      background: white;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      overflow-y: auto;
      transition: right 0.3s ease;
      z-index: 998;
      padding: 20px;
    }
    .right-panel.open { right: 0; }
    @media (max-width: 900px) {
      .charts-grid { grid-template-columns: 1fr; }
      .main-content { padding: 16px; }
      .right-panel { width: 98vw; }
    }
    .view-btn {
      padding: 4px 8px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .view-btn:hover { background: #0056b3; }
    .call-log-btn {
      padding: 4px 8px;
      background: #28a745;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 4px;
    }
    .call-log-btn:hover { background: #1e7e34; }
    .filter-section {
      border-top: 1px solid #e6e6e6;
      margin-top: 16px;
      padding-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .filter-group .filter-label {
      color: #0056b3;
      font-size: 0.95em;
      margin-bottom: 0;
    }
    .date-range-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .date-range-row span {
      color: #6c757d;
      font-size: 0.85em;
      white-space: nowrap;
    }
    .date-range-row input[type="date"] {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      font-size: 0.9em;
    }
    .date-filter-actions {
      display: flex;
      gap: 8px;
    }
    .date-filter-actions button {
      flex: 1;
      padding: 6px 0;
      border-radius: 6px;
      border: 1px solid transparent;
      font-size: 0.9em;
      cursor: pointer;
    }
    .date-filter-actions .apply-btn {
      background: #0d6efd;
      color: #fff;
    }
    .date-filter-actions .clear-btn {
      background: #f8f9fa;
      color: #0d6efd;
      border-color: #cfe2ff;
    }
    .tagify {
      border-radius: 6px;
      border-color: #d0d7de;
      font-size: 0.9em;
    }
    .tagify__tag {
      background: #e7f1ff;
      color: #0d6efd;
    }
    .tagify__input {
      min-width: 80px;
    }
    /* Tab navigation styles */
    .nav-tabs {
      border-bottom: 1px solid #dee2e6;
      margin-bottom: 20px;
      padding-left: 0;
      list-style: none;
      display: flex;
    }
    .nav-tabs .nav-link {
      border: 1px solid transparent;
      padding: 8px 12px;
      cursor: pointer;
      margin-right: 4px;
    }
    .nav-tabs .nav-link.active {
      border: 1px solid #dee2e6;
      border-bottom-color: #fff;
      background: #fff;
    }
    .tab-pane { display: none; }
    .tab-pane.active { display: block; }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal-content {
      background: #fff;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      padding: 20px;
      border-radius: 8px;
      position: relative;
    }
    .modal-content .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
    }
    body.modal-open {
      overflow: hidden;
    }
  </style>
</head>
<body>
  <!-- Left Sidebar -->
  <div class="sidebar" id="sidebar">
    <button class="toggle-arrow" onclick="toggleSidebar()">‹</button>

    <h3>RCM System</h3>
   <div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'Dashboard')">📊 <span class="menu-text">Dashboard</span></div><div class="menu-item active" onclick="showDashboardPanel(this)"><i data-feather="trending-up" style="margin-right:6px;"></i><span class="menu-text">AR Dashboard</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'Unbilled Dashboard')"><i data-feather="clock" style="margin-right:6px;"></i><span class="menu-text">Unbilled Dashboard</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'Authorization')"><i data-feather="check-circle" style="margin-right:6px;"></i><span class="menu-text">Authorization</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'Validation')"><i data-feather="alert-circle" style="margin-right:6px;"></i><span class="menu-text">Validation</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'Claims')"><i data-feather="file-text" style="margin-right:6px;"></i><span class="menu-text">Claims</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'UnbilledAR')"><i data-feather="alert-octagon" style="margin-right:6px;"></i><span class="menu-text">UnbilledAR</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'BilledAR')"><i data-feather="dollar-sign" style="margin-right:6px;"></i><span class="menu-text">BilledAR</span></div><div class="menu-item" onclick=" FileMaker.PerformScript('OnClickRCMMenu', 'Queue Manager')"><i data-feather="shuffle" style="margin-right:6px;"></i><span class="menu-text">Queue Manager</span></div><div class="menu-item" onclick="FileMaker.PerformScript('OnClickRCMMenu', 'Settings')"><i data-feather="settings" style="margin-right:6px;"></i><span class="menu-text">Settings</span></div>
    </div>

    <!-- Optional: Add sidebar menu items here -->
  </div>


 <!-- Main Content -->
  <div class="main-content">
    <div id="dashboard">
      <div class="dashboard-title">RCM Queue Dashboard</div>
      <button id="clearFilters" onclick="clearAllFilters()" style="margin-bottom:10px;">Clear All Filters</button>
      <ul class="nav nav-tabs" id="dashboardTabs">
        <li class="nav-item"><a class="nav-link active" href="#tab-overview">Overview</a></li>
        <li class="nav-item"><a class="nav-link" href="#tab-trends">Trends</a></li>
        <li class="nav-item"><a class="nav-link" href="#tab-activity">Activity Logs</a></li>
      </ul>
      <div class="tab-content">
        <div id="tab-overview" class="tab-pane active">
          <details open>
            <summary>Performance</summary>
            <div class="charts-grid">
              <div class="chart-card" data-chart="assignedTo" title="Tracks how queues are distributed across individual billers. Useful for managing productivity and ensuring balanced workload for team members actively resolving queues.">
                <div class="chart-title">Assigned To Distribution</div>
                <canvas id="assignedToChart"></canvas>
              </div>
              <div class="chart-card" data-chart="admin" title="Reflects ownership of queues at the admin level. If a queue is assigned to an Admin, they are expected to be the primary driver of resolution, while the AssignedTo (biller) acts in a supporting role.">
                <div class="chart-title">Admin Distribution</div>
                <canvas id="adminChart"></canvas>
              </div>
              <div class="chart-card" data-chart="highPriority" title="Isolates and visualizes Queues marked as ‘High’ priority. Allows quick intervention in time-sensitive cases. Also represented numerically in #highPriorityCount.">
                <div class="chart-title">High Priority Queues</div>
                <canvas id="highPriorityChart"></canvas>
              </div>
              <div class="chart-card" data-chart="overdue" title="Flags Queues where DueDate < Today. Indicates missed timelines and potential revenue delays. Also summarized in #overdueCount.">
                <div class="chart-title">Overdue Queues</div>
                <canvas id="overdueChart"></canvas>
              </div>
            </div>
          </details>

          <details>
            <summary>Queue Overview</summary>
            <div class="charts-grid">
              <div class="chart-card" data-chart="parentUnit" title="Visualizes the distribution of queues across different care units (e.g., Home Health, Hospice). Helps identify where queue volume is concentrated at the organizational level.">
                <div class="chart-title">Queues by Parent Unit</div>
                <canvas id="parentUnitChart"></canvas>
              </div>
              <div class="chart-card" data-chart="status" title="Shows the current processing status of Queues (e.g., Billed, Denied, RFNP). Useful for quickly understanding bottlenecks and queue stages.">
                <div class="chart-title">Status Breakdown</div>
                <canvas id="statusChart"></canvas>
              </div>
              <div class="chart-card" data-chart="priority" title="Displays Queue counts segmented by priority levels (e.g., Low, Medium, High). Useful for assessing urgency and workload severity across the team.">
                <div class="chart-title">Priority Trend</div>
                <canvas id="priorityChart"></canvas>
              </div>
              <div class="chart-card" data-chart="payor" title="Breaks down volume by insurance payor (e.g., Medicare PPS, Kaiser, UHC). Useful for identifying key payors and monitoring high-volume relationships.">
                <div class="chart-title">Queues by Payor</div>
                <canvas id="payorChart"></canvas>
              </div>
              <div class="chart-card" data-chart="queueAging" title="Categorizes Queues by how long they’ve been in the queue, based on the number of days since QueueDate. Supports aging reports and time-to-resolution improvement.">
                <div class="chart-title">Queue Aging</div>
                <canvas id="queueAgingChart"></canvas>
              </div>
              <div class="chart-card" data-chart="rfnp" title="Highlights why Queues were returned or unpaid. Essential for RCM teams to spot recurring issues and reduce denials.">
                <div class="chart-title">RFNP Breakdown</div>
                <canvas id="rfnpChart"></canvas>
              </div>
              <div class="chart-card" data-chart="subRfnp" title="Provides deeper insight into subcategories of non-payment causes. Helps prioritize training, process fixes, or payor escalation strategies.">
                <div class="chart-title">subRFNP Breakdown</div>
                <canvas id="subRfnpChart"></canvas>
              </div>
            </div>
          </details>

          
          <details>

            <summary>Documentation</summary>
            <div class="charts-grid">
              <div class="chart-card" data-chart="ub04Correspondence" title="Counts Queues with UB04 or Correspondence flags for quick tracking of documentation statuses.">
                <div class="chart-title">UB04 &amp; Correspondence</div>
                <canvas id="ub04CorrespondenceChart"></canvas>
              </div>
            </div>
          </details>
        </div>

        <div id="tab-trends" class="tab-pane">
          <div class="charts-grid">
            <div class="chart-card" data-chart="dueDateTrend" title="Displays weekly trends in upcoming Queue due dates. Useful for forecasting workload and aligning team capacity to demand.">
              <div class="chart-title">Due Date Trend</div>
              <canvas id="dueDateTrendChart"></canvas>
            </div>
            <div class="chart-card" data-chart="dueDateThisWeek" title="Segments Queues due in the current calendar week by weekday. Helps prioritize daily workflow for short-term execution.">
              <div class="chart-title">Queues Due This Week</div>
              <canvas id="dueDateThisWeekChart"></canvas>
            </div>
          </div>
        </div>

        <div id="tab-activity" class="tab-pane">
          <div class="charts-grid">
            <div class="chart-card" data-chart="logsEditsByUser">
              <div class="chart-title">Edits by User</div>
              <canvas id="logsEditsByUserChart"></canvas>
            </div>
            <div class="chart-card" data-chart="logsNewVsEdit">
              <div class="chart-title">New vs Edit by Day</div>
              <canvas id="logsNewVsEditChart"></canvas>
            </div>
            <div class="chart-card" data-chart="logsChangesByTable">
              <div class="chart-title">Changes by Table</div>
              <canvas id="logsChangesByTableChart"></canvas>
            </div>
            <div class="chart-card" data-chart="logsUserTypeHeatmap">
              <div class="chart-title">User vs Type Heatmap</div>
              <canvas id="logsUserTypeHeatmapChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      <div id="data-table">
        <div class="filter-label">Details Table (Filtered):</div>
        <table>
          <thead>
            <tr>
              <th>Queue ID</th>
              <th>Patient</th>
              <th>Payor Name</th>
              <th>Parent Unit</th>
              <th>Priority</th>
              <th>Status</th>
              <th>RFNP</th>
              <th>subRFNP</th>
              <th>Assigned To</th>
              <th>Admin</th>
              <th>Due Date</th>
              <th>Event Date</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Right Sidebar Toggle Button -->
  <div class="right-panel-toggle" onclick="toggleRightPanel()">❯</div>
  <!-- Right Sidebar Panel -->
  <div class="right-panel" id="rightPanel">
    <details id="chartDropdown">
      <summary>Show/Hide Charts</summary>
      <div id="chartOptions"></div>
    </details>
    <div class="filter-section">
      <div class="filter-group">
        <div class="filter-label">Event Date</div>
        <div class="date-range-row">
          <input type="date" id="eventDateStart" aria-label="Event date start">
          <span>to</span>
          <input type="date" id="eventDateEnd" aria-label="Event date end">
        </div>
        <div class="date-filter-actions">
          <button type="button" class="apply-btn" onclick="applyDateFilter()">Apply</button>
          <button type="button" class="clear-btn" onclick="clearDateFilter()">Clear</button>
        </div>
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterAssignedTo">Assigned To</label>
        <input id="filterAssignedTo" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterAdmin">Assigned Admin</label>
        <input id="filterAdmin" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterPatient">Patient</label>
        <input id="filterPatient" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterPayor">Payor Name</label>
        <input id="filterPayor" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterParentUnit">Parent Unit</label>
        <input id="filterParentUnit" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterStatus">Status</label>
        <input id="filterStatus" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterSourceTable">Source Table</label>
        <input id="filterSourceTable" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterPriority">Priority</label>
        <input id="filterPriority" placeholder="Search and select" />
      </div>
      <div class="filter-group">
        <label class="filter-label" for="filterRfnp">RFNP</label>
        <input id="filterRfnp" placeholder="Search and select" />
      </div>
    </div>
  </div>

  <div id="assignedToModal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" tabindex="-1">
      <button class="close-btn" onclick="closeAssignedToModal()" aria-label="Close">&times;</button>
      <div id="assignedToModalContent"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const tabLinks = document.querySelectorAll('#dashboardTabs .nav-link');
      const tabPanes = document.querySelectorAll('.tab-pane');
      tabLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          tabLinks.forEach(l => l.classList.remove('active'));
          tabPanes.forEach(p => p.classList.remove('active'));
          this.classList.add('active');
          document.querySelector(this.getAttribute('href')).classList.add('active');
        });
      });
    });
    // Left sidebar toggle
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('collapsed');
    }
    // Right panel toggle
    function toggleRightPanel() {
      const panel = document.getElementById('rightPanel');
      panel.classList.toggle('open');
    }

    let zoomLevel = 1;
    function applyZoom() {
      const dash = document.getElementById('data-table');
      dash.style.transform = `scale(${zoomLevel})`;
      dash.style.transformOrigin = '0 0';
    }
    function zoomIn() {
      zoomLevel = Math.min(2, zoomLevel + 0.1);
      applyZoom();
    }
    function zoomOut() {
      zoomLevel = Math.max(0.5, zoomLevel - 0.1);
      applyZoom();
    }

    let currentZoomCard = null;
    function zoomChart(card) {
      const cards = document.querySelectorAll('.chart-card');
      if (currentZoomCard === card) {
        cards.forEach(c => c.classList.remove('zoomed', 'dimmed'));
        currentZoomCard = null;
        return;
      }
      cards.forEach(c => {
        if (c === card) {
          c.classList.add('zoomed');
          c.classList.remove('dimmed');
        } else {
          c.classList.add('dimmed');
          c.classList.remove('zoomed');
        }
      });
      currentZoomCard = card;
    }

    function openPanelRecord(queueID, sourceTable, mrn, claimID) {
      const param = JSON.stringify({
        QueueID: queueID,
        ClaimID: claimID,
        MRN: mrn,
        SourceTable: sourceTable
      });
      if (window.FileMaker && window.FileMaker.PerformScript) {
        FileMaker.PerformScript('OpenPanelRecord', param);
      } else {
        const url =
          'fmp://$/QueueManager?script=OpenPanelRecord&param=' + encodeURIComponent(param);
        window.location.href = url;
      }
    }

    function openCallLog(queueID, sourceTable, mrn, claimID) {
      const param = JSON.stringify({
        QueueID: queueID,
        ClaimID: claimID,
        MRN: mrn,
        SourceTable: sourceTable
      });
      if (window.FileMaker && window.FileMaker.PerformScript) {
        FileMaker.PerformScript('OpenCallLog', param);
      } else {
        const url =
          'fmp://$/QueueManager?script=OpenCallLog&param=' + encodeURIComponent(param);
        window.location.href = url;
      }
    }

    let previousFocus, assignedToModalChart;

    function openAssignedToModal() {
      const modal = document.getElementById('assignedToModal');
      const content = document.getElementById('assignedToModalContent');
      const data = assignedToData(filterData());

      content.innerHTML = '<canvas id="assignedToModalCanvas"></canvas>';
      content.style.width = '90vw';
      content.style.height = '80vh';
      const canvas = document.getElementById('assignedToModalCanvas');
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      const ctx = canvas.getContext('2d');
      assignedToModalChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: data.labels,
          datasets: [{
            label: '# Claims',
            data: data.values,
            backgroundColor: 'rgba(0, 123, 255, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('AssignedTo', label === "(Unassigned)" ? "" : label);
            }
            updateAllCharts();
          },
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { autoSkip: false } },
            y: { beginAtZero: true }
          }
        }
      });

      assignedToModalChart.data.datasets[0].baseColor = 'rgba(0, 123, 255, 0.6)';
      setChartColors(assignedToModalChart, 'AssignedTo');

      previousFocus = document.activeElement;
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('modal-open');

      content.tabIndex = -1;

      content.focus();
    }

    function closeAssignedToModal() {
      const modal = document.getElementById('assignedToModal');

      if (assignedToModalChart) {
        assignedToModalChart.destroy();
        assignedToModalChart = null;
      }

      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('modal-open');
      if (previousFocus) {
        previousFocus.focus();
      }
    }
    // ---- SAMPLE DATA (Replace with your actual JSON!) ----
let rawData = [
 {"Admin":"","AssignedTo":"Ann Miranda","Call Log":"","ClaimID":"110702_76973_250721250724","Correspondence":"","DueDate":"8/18/2025","Event Date":"7/21/2025 - 7/24/2025","MRN":"11045645702","Parent Unit":"Home Health","Patient":"Leushtrng, Vinchrtent","Payor Name":"HPSM Care Advantage","Priority":"Low","QueueDate":"8/8/2025 4:59:30 PM","QueueID":"4E3BEEA3-AC1D-484F-A848-F1B2DDFCC592","RFNP":"","Related":{"LOG":[{"Date":"8/8/2025","Table":"Queue","Type":"New","User":"annmiranda@anxlife.com"}]},"SourceTable":"BilledAR","Status":"Billed","UB04":"","subRFNP":""},
{"Admin":"","AssignedTo":"Ann Miranda","Call Log":"","ClaimID":"104604_76947_250730250730","Correspondence":"","DueDate":"8/18/2025","Event Date":"7/30/2025 - 7/30/2025","MRN":"1044565604","Parent Unit":"Home Health","Patient":"Cashstrtro, Yadthira","Payor Name":"HPSM Care Advantage","Priority":"Low","QueueDate":"8/8/2025 4:59:30 PM","QueueID":"B60BB9EA-A226-4944-892C-F9476C0D951F","RFNP":"","Related":{"LOG":[{"Date":"8/8/2025","Table":"Queue","Type":"New","User":"annmiranda@anxlife.com"}]},"SourceTable":"BilledAR","Status":"Billed","UB04":"","subRFNP":""},
{"Admin":"","AssignedTo":"Johann Castaneda","Call Log":"","ClaimID":"400452_250625","Correspondence":"","DueDate":"8/22/2025","Event Date":"6/29/2025","MRN":"4004565452","Parent Unit":"Hospice","Patient":"T, Curghc B.","Payor Name":"SCFHP Room and Board","Priority":"Low","QueueDate":"8/8/2025 5:23:50 PM","QueueID":"FB4E556A-9407-C048-AC6E-E5A2E45E9DAE","RFNP":"","Related":{"LOG":[{"Date":"8/8/2025","Table":"Queue","Type":"Edit","User":"johanncastaneda@anxlife.com"},{"Date":"8/8/2025","Table":"Queue","Type":"Edit","User":"johanncastaneda@anxlife.com"},{"Date":"8/8/2025","Table":"Queue","Type":"Edit","User":"johanncastaneda@anxlife.com"},{"Date":"8/8/2025","Table":"Queue","Type":"Edit","User":"johanncastaneda@anxlife.com"},{"Date":"8/8/2025","Table":"Queue","Type":"New","User":"johanncastaneda@anxlife.com"}]},"SourceTable":"Claims","Status":"Sequential Billing","UB04":"","subRFNP":""}
];
    let currentFilter = {};
    const multiValueFields = new Set([
      'AssignedTo',
      'Admin',
      'Patient',
      'Payor Name',
      'Parent Unit',
      'Status',
      'SourceTable',
      'Priority',
      'RFNP'
    ]);
    const tagifyFieldConfig = [
      { field: 'AssignedTo', selector: '#filterAssignedTo' },
      { field: 'Admin', selector: '#filterAdmin' },
      { field: 'Patient', selector: '#filterPatient' },
      { field: 'Payor Name', selector: '#filterPayor' },
      { field: 'Parent Unit', selector: '#filterParentUnit' },
      { field: 'Status', selector: '#filterStatus' },
      { field: 'SourceTable', selector: '#filterSourceTable' },
      { field: 'Priority', selector: '#filterPriority' },
      { field: 'RFNP', selector: '#filterRfnp' }
    ];
    const tagifyInstances = {};
    let suppressFilterUpdate = false;

    function getFilterKey() {
      const user = window.currentUserEmail || window.userEmail || '';
      return `filters_${user}`;
    }

    function saveFilters() {
      localStorage.setItem(getFilterKey(), JSON.stringify(currentFilter));
    }

    function loadFilters() {
      const saved = localStorage.getItem(getFilterKey());
      if (saved) {
        try {
          currentFilter = JSON.parse(saved);
        } catch (e) {
          currentFilter = {};
        }
      }
    }

    function toggleFilter(field, value) {
      if (multiValueFields.has(field)) {
        let values = [];
        if (Array.isArray(currentFilter[field])) {
          values = [...currentFilter[field]];
        } else if (currentFilter[field] !== undefined) {
          values = [currentFilter[field]];
        }
        const idx = values.indexOf(value);
        if (idx >= 0) {
          values.splice(idx, 1);
        } else {
          values.push(value);
        }
        if (values.length) {
          currentFilter[field] = values;
        } else {
          delete currentFilter[field];
        }
        syncFiltersToUI();
      } else {
        if(currentFilter[field] === value) {
          delete currentFilter[field];
        } else {
          currentFilter[field] = value;
        }
      }
      saveFilters();
    }

    function clearAllFilters() {
      currentFilter = {};
      localStorage.removeItem(getFilterKey());
      syncFiltersToUI();
      updateAllCharts();
    }

    function setChartColors(chart, field, condition) {
      const highlight = 'rgba(255,99,132,0.9)';
      if(chart.config.type === 'line') {
        chart.data.datasets.forEach(ds => {
          const base = ds.baseColor;
          ds.pointBackgroundColor = chart.data.labels.map((lbl, idx) => {
            const match = condition ? condition(lbl) : matchesFilterValue(currentFilter[field], lbl);
            if(match) return highlight;
            if(Array.isArray(base)) return base[idx % base.length];
            return base;
          });
        });
        return;
      }
      const ds = chart.data.datasets[0];
      const base = ds.baseColor;
      if(chart.config.type === 'bubble') {
        ds.backgroundColor = ds.data.map((pt, idx) => {
          const match = condition ? condition(pt) : false;
          if(Array.isArray(base)) {
            const color = base[idx % base.length];
            return match ? highlight : color;
          }
          return match ? highlight : base;
        });
        return;
      }
      const labels = chart.data.labels;
      ds.backgroundColor = labels.map((lbl, idx) => {
        const match = condition ? condition(lbl) : matchesFilterValue(currentFilter[field], lbl);
        if(Array.isArray(base)) {
          const color = base[idx % base.length];
          return match ? highlight : color;
        }
        return match ? highlight : base;
      });
    }

    function includesText(target, query) {
      if (target === undefined || target === null) return false;
      if (query === undefined || query === null) return false;
      const haystack = String(target).toLowerCase();
      const needle = String(query).toLowerCase();
      if (!needle.trim()) return false;
      return haystack.includes(needle);
    }

    function matchesFilterValue(filterValue, label) {
      if (filterValue === undefined) return false;
      if (Array.isArray(filterValue)) {
        return filterValue.some(val => includesText(label, val));
      }
      return includesText(label, filterValue);
    }

    function parseISODate(str) {
      if (!str) return null;
      const [y, m, d] = str.split('-').map(n => parseInt(n, 10));
      if ([y, m, d].some(isNaN)) return null;
      return new Date(y, m - 1, d);
    }

    function applyDateFilter() {
      const startInput = document.getElementById('eventDateStart');
      const endInput = document.getElementById('eventDateEnd');
      if (!startInput || !endInput) return;
      const start = startInput.value;
      const end = endInput.value;
      let range = { start, end };
      if (start && end && start > end) {
        range = { start: end, end: start };
      }
      if (range.start || range.end) {
        currentFilter.EventDateRange = range;
        startInput.value = range.start || '';
        endInput.value = range.end || '';
      } else {
        delete currentFilter.EventDateRange;
      }
      saveFilters();
      updateAllCharts();
    }

    function clearDateFilter() {
      const startInput = document.getElementById('eventDateStart');
      const endInput = document.getElementById('eventDateEnd');
      if (startInput) startInput.value = '';
      if (endInput) endInput.value = '';
      delete currentFilter.EventDateRange;
      saveFilters();
      updateAllCharts();
    }

    function getUniqueValues(field) {
      const set = new Set();
      rawData.forEach(rec => {
        const val = rec[field];
        if (Array.isArray(val)) {
          val.forEach(v => {
            if (v) set.add(v);
          });
        } else if (val !== undefined && val !== null && String(val).trim() !== '') {
          set.add(String(val));
        }
      });
      return Array.from(set).sort((a, b) => a.localeCompare(b));
    }

    function initTagifyFilters() {
      if (!window.Tagify) return;
      tagifyFieldConfig.forEach(cfg => {
        const input = document.querySelector(cfg.selector);
        if (!input) return;
        const values = getUniqueValues(cfg.field);
        const tagify = new Tagify(input, {
          whitelist: values,
          enforceWhitelist: false,
          dropdown: {
            enabled: 0,
            maxItems: 20,
            fuzzySearch: true,
            closeOnSelect: false
          }
        });
        tagifyInstances[cfg.field] = tagify;
        tagify.on('add', () => applyTagifyFilter(cfg.field));
        tagify.on('remove', () => applyTagifyFilter(cfg.field));
      });
    }

    function refreshTagifyFilters() {
      Object.entries(tagifyInstances).forEach(([field, instance]) => {
        const values = getUniqueValues(field);
        instance.settings.whitelist = values;
        instance.dropdown.hide();
      });
    }

    function applyTagifyFilter(field) {
      if (suppressFilterUpdate) return;
      const instance = tagifyInstances[field];
      if (!instance) return;
      const selected = instance.value.map(tag => tag.value);
      if (selected.length) {
        currentFilter[field] = selected;
      } else {
        delete currentFilter[field];
      }
      saveFilters();
      updateAllCharts();
    }

    function syncFiltersToUI() {
      suppressFilterUpdate = true;
      Object.entries(tagifyInstances).forEach(([field, instance]) => {
        instance.removeAllTags();
        const selected = currentFilter[field];
        if (selected === undefined) return;
        const values = (Array.isArray(selected) ? selected : [selected]).filter(v => String(v).trim() !== '');
        if (values.length) {
          instance.addTags(values);
        }
      });
      const startInput = document.getElementById('eventDateStart');
      const endInput = document.getElementById('eventDateEnd');
      const range = currentFilter.EventDateRange || {};
      if (startInput) startInput.value = range.start || '';
      if (endInput) endInput.value = range.end || '';
      suppressFilterUpdate = false;
    }

    function normalizeDate(str) {
      if(!str) return '';
      // Strip any time portion and parse the date in local time
      const datePart = str.split(' ')[0];
      const parsed = new Date(datePart);
      if(!isNaN(parsed)) {
        const year = parsed.getFullYear();
        const month = String(parsed.getMonth() + 1).padStart(2, '0');
        const day = String(parsed.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }
      if(datePart.includes('/')) {
        const [m, d, y] = datePart.split('/');
        return `${y.padStart(4,'0')}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
      }
      if(datePart.includes('-')) {
        const [y, m, d] = datePart.split('-');
        if(y.length === 4) return `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
      }
      return datePart;
    }

    function extractLogsFromData(data) {
      const logs = [];
      data.forEach(rec => {
        if(rec.Related && Array.isArray(rec.Related.LOG)) {
          rec.Related.LOG.forEach(log => {
            logs.push({ ...log, Date: normalizeDate(log.Date) });
          });
        }
      });
      return logs;
    }

    function logsEditsByUser(logs) {
      const count = {};
      logs.filter(l => l.Type === 'Edit').forEach(l => {
        const user = l.User || '(Unknown)';
        count[user] = (count[user] || 0) + 1;
      });
      return { labels: Object.keys(count), values: Object.values(count) };
    }

    function logsNewVsEditByDay(logs) {
      const map = {};
      logs.forEach(l => {
        const date = l.Date;
        if(!date) return;
        if(!map[date]) map[date] = { New: 0, Edit: 0 };
        if(l.Type === 'New') map[date].New++;
        else if(l.Type === 'Edit') map[date].Edit++;
      });
      const labels = Object.keys(map).sort();
      return {
        labels,
        newValues: labels.map(d => map[d].New),
        editValues: labels.map(d => map[d].Edit)
      };
    }

    function logsChangesByTable(logs) {
      const count = {};
      logs.forEach(l => {
        const table = l.Table || '(Unknown)';
        count[table] = (count[table] || 0) + 1;
      });
      return { labels: Object.keys(count), values: Object.values(count) };
    }

    function logsUserTypeMatrix(logs) {
      const users = Array.from(new Set(logs.map(l => l.User || '(Unknown)')));
      const types = Array.from(new Set(logs.map(l => l.Type || '(Unknown)')));
      const combo = {};
      logs.forEach(l => {
        const user = l.User || '(Unknown)';
        const type = l.Type || '(Unknown)';
        const key = user + '|' + type;
        combo[key] = (combo[key] || 0) + 1;
      });
      const dataPoints = Object.entries(combo).map(([key, count]) => {
        const [user, type] = key.split('|');
        return { x: users.indexOf(user), y: types.indexOf(type), r: Math.max(5, count * 3) };
      });
      return { users, types, data: dataPoints };
    }

    function assignedToData(data) {
      let count = {};
      data.forEach(d => {
        let key = d.AssignedTo ? d.AssignedTo : '(Unassigned)';
        count[key] = (count[key]||0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
    function statusData(data) {
      let count = {};
      data.forEach(d => {
        let key = d.Status ? d.Status : '(No Status)';
        count[key] = (count[key]||0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
    function priorityData(data) {
      let count = {};
      data.forEach(d => {
        let key = d.Priority ? d.Priority : '(None)';
        count[key] = (count[key]||0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
      function payorData(data) {
        let count = {};
        data.forEach(d => {
          let key = d["Payor Name"] ? d["Payor Name"] : '(Unknown)';
          count[key] = (count[key]||0) + 1;
        });
        return {
          labels: Object.keys(count),
          values: Object.values(count)
        };
      }
      function highPriorityByAssignedTo(data) {
      let count = {};
      data.forEach(d => {
        if (d.Priority === 'High') {
          let key = d.AssignedTo ? d.AssignedTo : '(Unassigned)';
          count[key] = (count[key] || 0) + 1;
        }
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
    function overdueVsDueThisWeek(data) {
      let today = new Date();
      let startOfWeek = new Date(today);
      startOfWeek.setDate(today.getDate() - today.getDay());
      startOfWeek.setHours(0,0,0,0);
      let endOfWeek = new Date(startOfWeek);
      endOfWeek.setDate(startOfWeek.getDate() + 6);
      let count = { overdue: 0, "due this week": 0 };
      data.forEach(d => {
        let due = new Date(d.DueDate);
        if (isNaN(due)) return;
        if (due < today) {
          count.overdue++;
        } else if (due >= startOfWeek && due <= endOfWeek) {
          count["due this week"]++;
        }
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
    function parentUnitData(data) {
      let count = {};
      data.forEach(d => {
        let key = d["Parent Unit"]  ? d["Parent Unit"]  : '(Unknown)';
        count[key] = (count[key] || 0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }

    function ub04CorrespondenceData(data) {
      let ub04Count = 0;
      let corrCount = 0;
      let callLogCount = 0;
      data.forEach(d => {
        if (d["UB04"]) ub04Count++;
        if (d["Correspondence"]) corrCount++;
        if (d["Call Log"]) callLogCount++;
      });
      return {
        labels: ["UB04", "Correspondence", "Call Log"],
        values: [ub04Count, corrCount, callLogCount]
      };
    }

    function rfnpData(data) {
      let count = {};
      data.forEach(d => {
        let key = d.RFNP ? d.RFNP : '(None)';
        count[key] = (count[key] || 0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }

    function subRfnpData(data) {
      let count = {};
      data.forEach(d => {
        let key = d.subRFNP ? d.subRFNP : '(None)';
        count[key] = (count[key] || 0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }

    function adminData(data) {
      let count = {};
      data.forEach(d => {
        let key = d.Admin ? d.Admin : '(None)';
        count[key] = (count[key] || 0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
    function dueDateTrendData(data) {
      let count = {};
      data.forEach(d => {
        let due = new Date(d.DueDate);
        if (isNaN(due)) return;
        let weekLabel = getWeekLabel(due);
        count[weekLabel] = (count[weekLabel] || 0) + 1;
      });
      return {
        labels: Object.keys(count),
        values: Object.values(count)
      };
    }
    function dueDateThisWeekData(data) {
      let today = new Date();
      let startOfWeek = new Date(today);
      startOfWeek.setDate(today.getDate() - today.getDay());
      startOfWeek.setHours(0,0,0,0);
      let endOfWeek = new Date(startOfWeek);
      endOfWeek.setDate(startOfWeek.getDate() + 6);
      let days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      let count = { Sun:0, Mon:0, Tue:0, Wed:0, Thu:0, Fri:0, Sat:0 };
      data.forEach(d => {
        let due = new Date(d.DueDate);
        if (isNaN(due)) return;
        if (due >= startOfWeek && due <= endOfWeek) {
          let label = days[due.getDay()];
          count[label] = (count[label] || 0) + 1;
        }
      });
      return {
        labels: days,
        values: days.map(day => count[day])
      };
    }
    function queueAgingData(data) {
      let today = new Date();
      let buckets = { '0-7': 0, '8-14': 0, '15-30': 0, '31-60': 0, '60+': 0 };
      data.forEach(d => {
        if (!d.QueueDate) return;
        let qDateStr = d.QueueDate.split('-')[0].trim();
        let qDate = new Date(qDateStr);
        if (isNaN(qDate)) qDate = new Date(d.QueueDate);
        if (isNaN(qDate)) return;
        let diff = Math.floor((today - qDate) / 86400000);
        if (diff <= 7) buckets['0-7']++;
        else if (diff <= 14) buckets['8-14']++;
        else if (diff <= 30) buckets['15-30']++;
        else if (diff <= 60) buckets['31-60']++;
        else buckets['60+']++;
      });
      return {
        labels: Object.keys(buckets),
        values: Object.values(buckets)
      };
    }
    function getWeekLabel(date) {
      let year = date.getFullYear();
      let firstDay = new Date(year, 0, 1);
      let days = Math.floor((date - firstDay) / 86400000);
      let week = Math.ceil((days + firstDay.getDay() + 1) / 7);
      return `${year}-W${week}`;
    }
    function renderTable(data) {
      const rows = data.map(d => [
        d.QueueID,
        d.Patient || "",
        d["Payor Name"] || "",
        d["Parent Unit"] || "",
        d.Priority || "",
        d.Status || "",
        d.RFNP || "",
        d.subRFNP || "",
        d.AssignedTo || "",
        d.Admin || "",
        d.DueDate || "",
        d["Event Date"] || "",
        `<button class="view-btn" onclick="openPanelRecord('${d.QueueID}','${d.SourceTable}','${d.MRN}','${d.ClaimID}')">View</button>` +
        (d["Call Log"] == "1" ? ` <button class="call-log-btn" onclick="openCallLog('${d.QueueID}','${d.SourceTable}','${d.MRN}','${d.ClaimID}')">Call Log</button>` : "")
      ]);

      if (table) {
        table.clear().destroy();
      }

      const html = rows.map(r => `<tr>${r.map(c => `<td>${c}</td>`).join('')}</tr>`).join('');
      $("#tableBody").html(html);

      table = $('#data-table table').DataTable({
        scrollX: true,
        scrollY: '400px',
        paging: true,
        ordering: true,
        lengthMenu: [10, 25, 50, 100],
        dom: 'Bfrtip',
        buttons: [
          { extend: 'excel', text: feather.icons["download"].toSvg() },
          { extend: 'csv', text: feather.icons["file-text"].toSvg() },
          { text: feather.icons["zoom-in"].toSvg(), action: function(){ zoomIn(); } },
          { text: feather.icons["zoom-out"].toSvg(), action: function(){ zoomOut(); } }
        ]
      });

      $('.dt-buttons #pageLength').remove();
      const pageLength = $('<select id="pageLength"></select>');
      table.settings().init().lengthMenu.forEach(len => {
        pageLength.append(`<option value="${len}">${len}</option>`);
      });
      $('.dt-buttons').append(pageLength);
      $('#pageLength').on('change', function() {
        table.page.len(parseInt($(this).val())).draw();
      });
    }
    function filterData() {
      let data = rawData;
      Object.entries(currentFilter).forEach(([field, value]) => {
        data = data.filter(d => {
          if (field === 'OverdueStatus') {
            let due = new Date(d.DueDate);
            if (isNaN(due)) return false;
            let today = new Date();
            let startOfWeek = new Date(today);
            startOfWeek.setDate(today.getDate() - today.getDay());
            startOfWeek.setHours(0,0,0,0);
            let endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);
            if (value === 'overdue') return due < today;
            if (value === 'due this week') return due >= startOfWeek && due <= endOfWeek;
            return false;
          } else if (field === 'DueDateWeek') {
            let due = new Date(d.DueDate);
            if (isNaN(due)) return false;
            return getWeekLabel(due) === value;
          } else if (field === 'DueDateDay') {
            let due = new Date(d.DueDate);
            if (isNaN(due)) return false;
            let days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            return days[due.getDay()] === value;
          } else if (field === 'QueueAgeRange') {
            if (!d.QueueDate) return false;
            let qDateStr = d.QueueDate.split('-')[0].trim();
            let qDate = new Date(qDateStr);
            if (isNaN(qDate)) qDate = new Date(d.QueueDate);
            if (isNaN(qDate)) return false;
            let diff = Math.floor((new Date() - qDate) / 86400000);
            let bucket;
            if (diff <= 7) bucket = '0-7';
            else if (diff <= 14) bucket = '8-14';
            else if (diff <= 30) bucket = '15-30';
            else if (diff <= 60) bucket = '31-60';
            else bucket = '60+';
            return bucket === value;
          } else if (field === 'LogUser') {
            return d.Related && Array.isArray(d.Related.LOG) && d.Related.LOG.some(l => (l.User || '(Unknown)') === value);
          } else if (field === 'LogDate') {
            const [y, m, dPart] = value.split('-').map(n => parseInt(n, 10));
            const start = new Date(y, m - 1, dPart);
            const end = new Date(y, m - 1, dPart + 1);
            return d.Related && Array.isArray(d.Related.LOG) && d.Related.LOG.some(l => {
              const ld = new Date(l.Date);
              if (isNaN(ld)) return false;
              return ld >= start && ld < end;
            });
          } else if (field === 'LogTable') {
            return d.Related && Array.isArray(d.Related.LOG) && d.Related.LOG.some(l => (l.Table || '(Unknown)') === value);
          } else if (field === 'LogUserType') {
            return d.Related && Array.isArray(d.Related.LOG) && d.Related.LOG.some(l => {
              const user = l.User || '(Unknown)';
              const type = l.Type || '(Unknown)';
              return user + '|' + type === value;
            });
          } else if (field === 'EventDateRange') {
            const eventDateStr = normalizeDate(d['Event Date']);
            if (!eventDateStr) return false;
            const eventDate = parseISODate(eventDateStr);
            if (!eventDate) return false;
            if (value.start) {
              const start = parseISODate(value.start);
              if (start && eventDate < start) return false;
            }
            if (value.end) {
              const end = parseISODate(value.end);
              if (end && eventDate > end) return false;
            }
            return true;
          } else {
            const recordValue = d[field] || '';
            if (Array.isArray(value)) {
              return value.some(val => includesText(recordValue, val));
            }
            return includesText(recordValue, value);
          }
        });
      });
      return data;
    }
    function updateAllCharts() {
      if (!assignedToChart) return;
      let data = filterData();
      let logs = extractLogsFromData(data);
      let leuData = logsEditsByUser(logs);
      logsEditsByUserChart.data.labels = leuData.labels;
      logsEditsByUserChart.data.datasets[0].data = leuData.values;
      setChartColors(logsEditsByUserChart, 'LogUser');
      logsEditsByUserChart.update();
      let lneData = logsNewVsEditByDay(logs);
      logsNewVsEditChart.data.labels = lneData.labels;
      logsNewVsEditChart.data.datasets[0].data = lneData.newValues;
      logsNewVsEditChart.data.datasets[1].data = lneData.editValues;
      setChartColors(logsNewVsEditChart, 'LogDate');
      logsNewVsEditChart.update();
      let lctData = logsChangesByTable(logs);
      logsChangesByTableChart.data.labels = lctData.labels;
      logsChangesByTableChart.data.datasets[0].data = lctData.values;
      setChartColors(logsChangesByTableChart, 'LogTable');
      logsChangesByTableChart.update();
      let lhmData = logsUserTypeMatrix(logs);
      logsUserTypeHeatmapChart.data.datasets[0].data = lhmData.data;
      logsUserTypeHeatmapChart.options.scales.x.ticks.callback = value => lhmData.users[value];
      logsUserTypeHeatmapChart.options.scales.y.ticks.callback = value => lhmData.types[value];
      logsUserTypeHeatmapChart.userLabels = lhmData.users;
      logsUserTypeHeatmapChart.typeLabels = lhmData.types;
      setChartColors(
        logsUserTypeHeatmapChart,
        null,
        pt => {
          const user = lhmData.users[pt.x];
          const type = lhmData.types[pt.y];
          return currentFilter.LogUserType !== undefined && currentFilter.LogUserType === user + '|' + type;
        }
      );
      logsUserTypeHeatmapChart.update();
      let aData = assignedToData(data);
      assignedToChart.data.labels = aData.labels;
      assignedToChart.data.datasets[0].data = aData.values;
      setChartColors(assignedToChart, 'AssignedTo');
      assignedToChart.update();
      if (assignedToModalChart) {
        assignedToModalChart.data.labels = aData.labels;
        assignedToModalChart.data.datasets[0].data = aData.values;
        setChartColors(assignedToModalChart, 'AssignedTo');
        assignedToModalChart.update();
      }
      let sData = statusData(data);
      statusChart.data.labels = sData.labels;
      statusChart.data.datasets[0].data = sData.values;
      setChartColors(statusChart, 'Status');
      statusChart.update();
      let pData = priorityData(data);
      priorityChart.data.labels = pData.labels;
      priorityChart.data.datasets[0].data = pData.values;
      setChartColors(priorityChart, 'Priority');
      priorityChart.update();
      let payData = payorData(data);
      payorChart.data.labels = payData.labels;
      payorChart.data.datasets[0].data = payData.values;
      setChartColors(payorChart, 'Payor Name');
      payorChart.update();
      let hpData = highPriorityByAssignedTo(data);
      highPriorityChart.data.labels = hpData.labels;
      highPriorityChart.data.datasets[0].data = hpData.values.map((v, i) => ({ x: i, y: v, r: Math.max(5, v * 3) }));
      highPriorityChart.options.scales.x.ticks.callback = function(value) { return hpData.labels[value]; };
      setChartColors(highPriorityChart, 'AssignedTo', label => currentFilter.Priority === 'High' && matchesFilterValue(currentFilter.AssignedTo, label));
      highPriorityChart.update();
      let odData = overdueVsDueThisWeek(data);
      overdueChart.data.labels = odData.labels;
      overdueChart.data.datasets[0].data = odData.values;
      setChartColors(overdueChart, 'OverdueStatus');
      overdueChart.update();
      let puData = parentUnitData(data);
      parentUnitChart.data.labels = puData.labels;
      parentUnitChart.data.datasets[0].data = puData.values;
      setChartColors(parentUnitChart, 'Parent Unit');
      parentUnitChart.update();
      let trendData = dueDateTrendData(data);
      dueDateTrendChart.data.labels = trendData.labels;
      dueDateTrendChart.data.datasets[0].data = trendData.values;
      setChartColors(dueDateTrendChart, 'DueDateWeek');
      dueDateTrendChart.update();
      let weekData = dueDateThisWeekData(data);
      dueDateThisWeekChart.data.labels = weekData.labels;
      dueDateThisWeekChart.data.datasets[0].data = weekData.values;
      setChartColors(dueDateThisWeekChart, 'DueDateDay');
      dueDateThisWeekChart.update();
      let agingData = queueAgingData(data);
      queueAgingChart.data.labels = agingData.labels;
      queueAgingChart.data.datasets[0].data = agingData.values;
      setChartColors(queueAgingChart, 'QueueAgeRange');
      queueAgingChart.update();

      let rfData = rfnpData(data);
      rfnpChart.data.labels = rfData.labels;
      rfnpChart.data.datasets[0].data = rfData.values;
      setChartColors(rfnpChart, 'RFNP');
      rfnpChart.update();

      let subData = subRfnpData(data);
      subRfnpChart.data.labels = subData.labels;
      subRfnpChart.data.datasets[0].data = subData.values;
      setChartColors(subRfnpChart, 'subRFNP');
      subRfnpChart.update();

      let ubData = ub04CorrespondenceData(data);
      ub04CorrespondenceChart.data.labels = ubData.labels;
      ub04CorrespondenceChart.data.datasets[0].data = ubData.values;
      setChartColors(
        ub04CorrespondenceChart,
        null,
        (lbl) =>
          (lbl === "UB04" && currentFilter.UB04 === "1") ||
          (lbl === "Correspondence" && currentFilter.Correspondence === "1") ||
          (lbl === "Call Log" && currentFilter["Call Log"] === "1")
      );
      ub04CorrespondenceChart.update();

      let adData = adminData(data);
      adminChart.data.labels = adData.labels;
      adminChart.data.datasets[0].data = adData.values;
      setChartColors(adminChart, 'Admin');
      adminChart.update();
      renderTable(data);
    }

    function reloadData(jsonString) {
      try {
        rawData = JSON.parse(jsonString);
      } catch (e) {
        console.error("Invalid JSON passed to reloadData:", e);
        return;
      }
      refreshTagifyFilters();
      syncFiltersToUI();
      renderTable(rawData);
      updateAllCharts();
    }
    window.reloadData = reloadData;

    function initChartDropdown() {
      const container = document.getElementById('chartOptions');
      const cards = document.querySelectorAll('.chart-card[data-chart]');
      const hidden = JSON.parse(localStorage.getItem('hiddenCharts') || '[]');
      cards.forEach(card => {
        const id = card.dataset.chart;
        const title = card.querySelector('.chart-title').textContent.trim();
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = id;
        cb.checked = !hidden.includes(id);
        cb.addEventListener('change', () => {
          card.style.display = cb.checked ? '' : 'none';
          save();
        });
        const label = document.createElement('label');

        label.appendChild(cb);
        label.appendChild(document.createTextNode(' ' + title));
        container.appendChild(label);

        card.style.display = cb.checked ? '' : 'none';
      });
      function save() {
        const hidden = [];
        container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
          if (!cb.checked) hidden.push(cb.value);
        });
        localStorage.setItem('hiddenCharts', JSON.stringify(hidden));
      }
    }

      let assignedToChart, statusChart, priorityChart, payorChart,
          highPriorityChart, overdueChart, parentUnitChart,
          dueDateTrendChart, dueDateThisWeekChart, queueAgingChart,
          rfnpChart, subRfnpChart, ub04CorrespondenceChart, adminChart,
          logsEditsByUserChart, logsNewVsEditChart, logsChangesByTableChart,
          logsUserTypeHeatmapChart, table;
    $(function() {
      loadFilters();
      initTagifyFilters();
      syncFiltersToUI();
      updateAllCharts();
      initChartDropdown();
      feather.replace();
      let aData = assignedToData(rawData);
      assignedToChart = new Chart($("#assignedToChart"), {
        type: 'bar',
        data: {
          labels: aData.labels,
          datasets: [{
            label: '# Claims',
            data: aData.values,
            backgroundColor: 'rgba(0, 123, 255, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('AssignedTo', label === "(Unassigned)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: {
            legend: { display: false }
          },
          responsive: true,
          scales: { y: { beginAtZero: true } }
        }
      });
      assignedToChart.data.datasets[0].baseColor = 'rgba(0, 123, 255, 0.6)';

      let sData = statusData(rawData);
      statusChart = new Chart($("#statusChart"), {
        type: 'doughnut',
        data: {
          labels: sData.labels,
          datasets: [{
            label: '# Claims',
            data: sData.values,
            backgroundColor: [
              '#0d6efd', '#6c757d', '#198754', '#ffc107', '#dc3545', '#adb5bd'
            ]
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('Status', label === "(No Status)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: { legend: { position: 'bottom' } },
          cutout: "65%"
        }
      });
      statusChart.data.datasets[0].baseColor = [
        '#0d6efd', '#6c757d', '#198754', '#ffc107', '#dc3545', '#adb5bd'
      ];

      let pData = priorityData(rawData);
      priorityChart = new Chart($("#priorityChart"), {
        type: 'bar',
        data: {
          labels: pData.labels,
          datasets: [{
            label: '# Claims',
            data: pData.values,
            backgroundColor: 'rgba(253, 126, 20, 0.7)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('Priority', label === "(None)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: {
            legend: { display: false }
          },
          responsive: true,
          scales: { y: { beginAtZero: true } }
        }
      });
      priorityChart.data.datasets[0].baseColor = 'rgba(253, 126, 20, 0.7)';

      let payData = payorData(rawData);
      payorChart = new Chart($("#payorChart"), {
        type: 'pie',
        data: {
          labels: payData.labels,
          datasets: [{
            label: '# Claims',
            data: payData.values,
            backgroundColor: [
              '#007bff','#6610f2','#6f42c1','#d63384','#fd7e14','#ffc107','#28a745','#20c997'
            ]
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('Payor Name', label === "(Unknown)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: { legend: { position: 'bottom' } }
        }
      });
      payorChart.data.datasets[0].baseColor = [
        '#007bff','#6610f2','#6f42c1','#d63384','#fd7e14','#ffc107','#28a745','#20c997'
      ];

      let hpData = highPriorityByAssignedTo(rawData);
      highPriorityChart = new Chart($("#highPriorityChart"), {
        type: 'bubble',
        data: {
          labels: hpData.labels,
          datasets: [{
            label: '# High Priority',
            data: hpData.values.map((v, i) => ({ x: i, y: v, r: Math.max(5, v * 3) })),
            backgroundColor: 'rgba(220, 53, 69, 0.7)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = hpData.labels[items[0].index];
              const val = label === "(Unassigned)" ? "" : label;
              const assignedFilter = currentFilter.AssignedTo;
              const singleMatch = Array.isArray(assignedFilter) ? (assignedFilter.length === 1 && assignedFilter[0] === val) : assignedFilter === val;
              if(currentFilter.Priority === 'High' && singleMatch) {
                delete currentFilter.AssignedTo;
                delete currentFilter.Priority;
              } else {
                currentFilter.AssignedTo = [val];
                currentFilter.Priority = 'High';
              }
              saveFilters();
              syncFiltersToUI();
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          scales: {
            x: {
              ticks: {
                callback: function(value) { return hpData.labels[value]; }
              }
            },
            y: { beginAtZero: true }
          }
        }
      });
      highPriorityChart.data.datasets[0].baseColor = 'rgba(220, 53, 69, 0.7)';

      let odData = overdueVsDueThisWeek(rawData);
      overdueChart = new Chart($("#overdueChart"), {
        type: 'doughnut',
        data: {
          labels: odData.labels,
          datasets: [{
            label: '# Claims',
            data: odData.values,
            backgroundColor: ['#dc3545', '#ffc107']
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('OverdueStatus', label);
            }
            updateAllCharts();
          },
          plugins: { legend: { position: 'bottom' } },
          cutout: '65%'
        }
      });
      overdueChart.data.datasets[0].baseColor = ['#dc3545', '#ffc107'];

      let puData = parentUnitData(rawData);
      parentUnitChart = new Chart($("#parentUnitChart"), {
        type: 'bar',
        data: {
          labels: puData.labels,
          datasets: [{
            label: '# Claims',
            data: puData.values,
            backgroundColor: 'rgba(40, 167, 69, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('Parent Unit', label === "(Unknown)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          indexAxis: 'y',
          scales: { x: { beginAtZero: true } }
        }
      });
      parentUnitChart.data.datasets[0].baseColor = 'rgba(40, 167, 69, 0.6)';

      let trendData = dueDateTrendData(rawData);
      dueDateTrendChart = new Chart($("#dueDateTrendChart"), {
        type: 'line',
        data: {
          labels: trendData.labels,
          datasets: [{
            label: '# Claims',
            data: trendData.values,
            fill: false,
            borderColor: '#007bff'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('DueDateWeek', label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          scales: { y: { beginAtZero: true } }
        }
      });
      dueDateTrendChart.data.datasets[0].baseColor = '#007bff';

      let weekData = dueDateThisWeekData(rawData);
      dueDateThisWeekChart = new Chart($("#dueDateThisWeekChart"), {
        type: 'bar',
        data: {
          labels: weekData.labels,
          datasets: [{
            label: '# Claims',
            data: weekData.values,
            backgroundColor: 'rgba(23, 162, 184, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('DueDateDay', label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          scales: { y: { beginAtZero: true } }
        }
      });
      dueDateThisWeekChart.data.datasets[0].baseColor = 'rgba(23, 162, 184, 0.6)';

      let agingData = queueAgingData(rawData);
      queueAgingChart = new Chart($("#queueAgingChart"), {
        type: 'bar', // histogram representation
        data: {
          labels: agingData.labels,
          datasets: [{
            label: '# Claims',
            data: agingData.values,
            backgroundColor: 'rgba(108, 117, 125, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('QueueAgeRange', label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          scales: { y: { beginAtZero: true } }
        }
      });
      queueAgingChart.data.datasets[0].baseColor = 'rgba(108, 117, 125, 0.6)';

      let rfData = rfnpData(rawData);
      rfnpChart = new Chart($("#rfnpChart"), {
        type: 'bar',
        data: {
          labels: rfData.labels,
          datasets: [{
            label: '# Claims',
            data: rfData.values,
            backgroundColor: 'rgba(255, 159, 64, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('RFNP', label === "(None)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          indexAxis: 'y',
          scales: { x: { beginAtZero: true } }
        }
      });
      rfnpChart.data.datasets[0].baseColor = 'rgba(255, 159, 64, 0.6)';

      let subData = subRfnpData(rawData);
      subRfnpChart = new Chart($("#subRfnpChart"), {
        type: 'bar',
        data: {
          labels: subData.labels,
          datasets: [{
            label: '# Claims',
            data: subData.values,
            backgroundColor: 'rgba(111, 66, 193, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('subRFNP', label === "(None)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          indexAxis: 'y',
          scales: { x: { beginAtZero: true } }
        }
      });
      subRfnpChart.data.datasets[0].baseColor = 'rgba(111, 66, 193, 0.6)';

      let ubData = ub04CorrespondenceData(rawData);
      ub04CorrespondenceChart = new Chart($("#ub04CorrespondenceChart"), {
        type: 'bar',
        data: {
          labels: ubData.labels,
          datasets: [{
            label: '# Claims',
            data: ubData.values,
            backgroundColor: [
              'rgba(40, 167, 69, 0.6)',
              'rgba(0, 123, 255, 0.6)',
              'rgba(100, 181, 246, 0.6)'
            ]
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              if(label === "UB04") {
                toggleFilter('UB04', '1');
              } else if(label === "Correspondence") {
                toggleFilter('Correspondence', '1');
              } else if(label === "Call Log") {
                toggleFilter('Call Log', '1');
              }
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          indexAxis: 'y',
          scales: { x: { beginAtZero: true } }
        }
      });
      ub04CorrespondenceChart.data.datasets[0].baseColor = [
        'rgba(40, 167, 69, 0.6)',
        'rgba(0, 123, 255, 0.6)',
        'rgba(100, 181, 246, 0.6)'
      ];

      let adData = adminData(rawData);
      adminChart = new Chart($("#adminChart"), {
        type: 'bar',
        data: {
          labels: adData.labels,
          datasets: [{
            label: '# Claims',
            data: adData.values,
            backgroundColor: 'rgba(0, 123, 255, 0.6)'
          }]
        },
        options: {
          onClick: function(e, items) {
            if(items.length) {
              const label = this.data.labels[items[0].index];
              toggleFilter('Admin', label === "(None)" ? "" : label);
            }
            updateAllCharts();
          },
          plugins: { legend: { display: false } },
          responsive: true,
          scales: { y: { beginAtZero: true } }
        }
      });
        adminChart.data.datasets[0].baseColor = 'rgba(0, 123, 255, 0.6)';

        let logs = extractLogsFromData(rawData);

        let leuData = logsEditsByUser(logs);
        logsEditsByUserChart = new Chart($("#logsEditsByUserChart"), {
          type: 'bar',
          data: {
            labels: leuData.labels,
            datasets: [{
              label: '# Edits',
              data: leuData.values,
              backgroundColor: 'rgba(0, 123, 255, 0.6)'
            }]
          },
          options: {
            onClick: function(e, items) {
              if(items.length) {
                const label = this.data.labels[items[0].index];
                toggleFilter('LogUser', label);
              }
              updateAllCharts();
            },
            plugins: { legend: { display: false } },
            responsive: true,
            scales: { y: { beginAtZero: true } }
          }
        });
        logsEditsByUserChart.data.datasets[0].baseColor = 'rgba(0, 123, 255, 0.6)';
        setChartColors(logsEditsByUserChart, 'LogUser');

        let lneData = logsNewVsEditByDay(logs);
        logsNewVsEditChart = new Chart($("#logsNewVsEditChart"), {
          type: 'line',
          data: {
            labels: lneData.labels,
            datasets: [
              {
                label: 'New',
                data: lneData.newValues,
                fill: false,
                borderColor: 'rgba(40, 167, 69, 0.7)',
                backgroundColor: 'rgba(40, 167, 69, 0.7)'
              },
              {
                label: 'Edit',
                data: lneData.editValues,
                fill: false,
                borderColor: 'rgba(220, 53, 69, 0.7)',
                backgroundColor: 'rgba(220, 53, 69, 0.7)'
              }
            ]
          },
          options: {
            onClick: function(e, items) {
              if(items.length) {
                const label = this.data.labels[items[0].index];
                toggleFilter('LogDate', label);
              }
              updateAllCharts();
            },
            plugins: { legend: { display: true } },
            responsive: true,
            scales: { y: { beginAtZero: true } }
          }
        });
        logsNewVsEditChart.data.datasets[0].baseColor = 'rgba(40, 167, 69, 0.7)';
        logsNewVsEditChart.data.datasets[1].baseColor = 'rgba(220, 53, 69, 0.7)';
        setChartColors(logsNewVsEditChart, 'LogDate');

        let lctData = logsChangesByTable(logs);
        logsChangesByTableChart = new Chart($("#logsChangesByTableChart"), {
          type: 'bar',
          data: {
            labels: lctData.labels,
            datasets: [{
              label: '# Logs',
              data: lctData.values,
              backgroundColor: 'rgba(255, 193, 7, 0.6)'
            }]
          },
          options: {
            onClick: function(e, items) {
              if(items.length) {
                const label = this.data.labels[items[0].index];
                toggleFilter('LogTable', label);
              }
              updateAllCharts();
            },
            plugins: { legend: { display: false } },
            responsive: true,
            scales: { y: { beginAtZero: true } }
          }
        });
        logsChangesByTableChart.data.datasets[0].baseColor = 'rgba(255, 193, 7, 0.6)';
        setChartColors(logsChangesByTableChart, 'LogTable');

        let lhmData = logsUserTypeMatrix(logs);
        logsUserTypeHeatmapChart = new Chart($("#logsUserTypeHeatmapChart"), {
          type: 'bubble',
          data: {
            datasets: [{
              label: 'Logs',
              data: lhmData.data,
              backgroundColor: 'rgba(0, 123, 255, 0.6)'
            }]
          },
          options: {
            onClick: function(e, elements) {
              if(elements.length) {
                const el = elements[0];
                const pt = this.data.datasets[el.datasetIndex].data[el.index];
                const user = this.userLabels[pt.x];
                const type = this.typeLabels[pt.y];
                toggleFilter('LogUserType', user + '|' + type);
              }
              updateAllCharts();
            },
            plugins: { legend: { display: false } },
            responsive: true,
            scales: {
              x: {
                beginAtZero: true,
                ticks: { callback: value => lhmData.users[value] }
              },
              y: {
                beginAtZero: true,
                ticks: { callback: value => lhmData.types[value] }
              }
            }
          }
        });
        logsUserTypeHeatmapChart.data.datasets[0].baseColor = 'rgba(0, 123, 255, 0.6)';
        logsUserTypeHeatmapChart.userLabels = lhmData.users;
        logsUserTypeHeatmapChart.typeLabels = lhmData.types;
        setChartColors(logsUserTypeHeatmapChart, null, () => false);

      $('.chart-card, .chart-card canvas').on('dblclick', function(e) {
        const card = $(this).closest('.chart-card');
        if (card.data('chart') === 'assignedTo') {
          openAssignedToModal();
        } else {
          zoomChart(card[0]);
        }
      });

      updateAllCharts();
      feather.replace();
      applyZoom();
    });
  </script>
</body>
</html>
